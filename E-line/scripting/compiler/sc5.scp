/*  Small compiler - Error message strings (plain and compressed formats)
 *
 *  Copyright (c) ITB CompuPhase, 2000-2002
 *  This file may be freely used. No warranties of any kind.
 *
 *  Version: $Id: sc5.scp,v 1.1.1.2 2003/05/07 14:50:07 darope Exp $
 */

SC_FUNC int strexpand(char *dest, unsigned char *source, int maxlen, unsigned char pairtable[128][2]);

#define SCPACK_TABLE errstr_table
/*-*SCPACK start of pair table, do not change or remove this line */
unsigned char errstr_table[][2] = {
  {116,32}, {101,32}, {111,110}, {105,110}, {100,32}, {97,114}, {105,130}, {101,110}, {101,114}, {115,32}, {97,108}, {97,116}, {114,101}, {117,110}, {109,135}, {97,110},
  {110,111}, {121,32}, {99,116}, {134,32}, {115,34}, {37,148}, {34,149}, {101,132}, {118,138}, {115,115}, {115,116}, {144,128}, {98,108}, {109,98}, {111,114}, {101,120},
  {105,132}, {102,141}, {117,142}, {161,146}, {152,160}, {103,162}, {133,165}, {114,97}, {101,100}, {99,104}, {41,10}, {131,164}, {163,147}, {97,32}, {117,115}, {32,150},
  {136,32}, {100,101}, {105,116}, {97,156}, {133,167}, {111,108}, {166,128}, {99,130}, {101,10}, {112,140}, {102,32}, {98,129}, {179,129}, {118,133}, {105,137}, {115,10},
  {180,145}, {111,186}, {177,102}, {131,103}, {189,105}, {175,10}, {97,153}, {121,157}, {158,32}, {199,181}, {196,188}, {115,201}, {109,97}, {100,105}, {174,128}, {139,134},
  {183,154}, {34,32}, {58,197}, {109,206}, {104,97}, {115,105}, {32,110}, {143,128}, {101,137}, {116,10}, {99,143}, {117,157}, {219,176}, {105,99}, {117,108}, {108,111},
  {112,111}, {116,111}, {111,112}, {194,131}, {109,139}, {226,136}, {202,150}, {218,155}, {185,153}, {44,32}, {195,32}, {228,169}, {133,97}, {116,104}, {159,232}, {97,115},
  {152,117}, {108,129}, {118,129}, {168,10}, {101,142}, {230,170}, {211,187}, {208,215}, {98,101}, {105,115}, {32,115}, {40,245}, {213,122}, {240,129}, {229,139}
};
/*-*SCPACK end of pair table, do not change or remove this line */

static char *errmsg[] = {
#ifdef SCPACK
/*001*/  "expected token: \"%s\", but found \"%s\"\n",
/*002*/  "only a single statement (or expression) can follow each \"case\"\n",
/*003*/  "reserved\n",
/*004*/  "function \"%s\" is not implemented\n",
/*005*/  "function may not have arguments\n",
/*006*/  "must be assigned to an array\n",
/*007*/  "assertion failed\n",
/*008*/  "must be a constant expression; assumed zero\n",
/*009*/  "invalid array size (negative or zero)\n",
/*010*/  "invalid function or declaration\n",
/*011*/  "invalid outside functions\n",
/*012*/  "invalid function call, not a valid address\n",
/*013*/  "no entry point (no public functions)\n",
/*014*/  "invalid statement; not in switch\n",
/*015*/  "\"default\" case must be the last case in switch statement\n",
/*016*/  "multiple defaults in \"switch\"\n",
/*017*/  "undefined symbol \"%s\"\n",
/*018*/  "initialization data exceeds declared size\n",
/*019*/  "not a label: \"%s\"\n",
/*020*/  "invalid symbol name \"%s\"\n",
/*021*/  "symbol already defined: \"%s\"\n",
/*022*/  "must be lvalue (non-constant)\n",
/*023*/  "array assignment must be simple assignment\n",
/*024*/  "\"break\" or \"continue\" is out of context\n",
/*025*/  "function heading differs from prototype\n",
/*026*/  "no matching \"#if...\"\n",
/*027*/  "invalid character constant\n",
/*028*/  "cannot subscript, not an array\n",
/*029*/  "invalid expression, assumed zero\n",
/*030*/  "compound statement not closed at the end of file\n",
/*031*/  "unknown directive\n",
/*032*/  "array index out of bounds (variable \"%s\")\n",
/*033*/  "array must be indexed (variable \"%s\")\n",
/*034*/  "argument does not have a default value (argument %d)\n",
/*035*/  "argument type mismatch (argument %d)\n",
/*036*/  "empty statement\n",
/*037*/  "invalid string (possibly non-terminated string)\n",
/*038*/  "extra characters on line\n",
/*039*/  "constant symbol has no size\n",
/*040*/  "duplicate \"case\" label (value %d)\n",
/*041*/  "invalid ellipsis, array size is not known\n",
/*042*/  "invalid combination of class specifiers\n",
/*043*/  "character constant exceeds range for packed string\n",
/*044*/  "positional parameters must precede all named parameters\n",
/*045*/  "too many function arguments\n",
/*046*/  "unknown array size (variable \"%s\")\n",
/*047*/  "array sizes must match\n",
/*048*/  "array dimensions must match\n",
/*049*/  "invalid line continuation\n",
/*050*/  "invalid range\n",
/*051*/  "invalid subscript, use \"[ ]\" operators on major dimensions\n",
/*052*/  "only the last dimension may be variable length\n",
/*053*/  "exceeding maximum number of dimensions\n",
/*054*/  "unmatched closing brace\n",
/*055*/  "start of function body without function header\n",
/*056*/  "local variables and function arguments cannot be public (variable \"%s\")\n",
/*057*/  "unfinished expression before compiler directive\n",
/*058*/  "duplicate argument; same argument is passed twice\n",
/*059*/  "function argument may not have a default value (variable \"%s\")\n",
/*060*/  "multiple \"#else\" directives between \"#if ... #endif\"\n",
/*061*/  "operator cannot be redefined\n",
/*062*/  "number of operands does not fit the operator\n",
/*063*/  "operator \"!\" requires an untagged function result\n",
/*064*/  "cannot change predefined operators\n",
/*065*/  "function argument may only have a single tag (argument %d)\n",
/*066*/  "function argument may not be a reference argument or an array (argument \"%s\")\n",
/*067*/  "variable cannot be both a reference and an array (variable \"%s\")\n",
/*068*/  "invalid rational number precision in #pragma\n",
/*069*/  "rational number format already defined\n",
/*070*/  "rational number support was not enabled\n",
/*071*/  "user-defined operator must be declared before use (function \"%s\")\n",
/*072*/  "\"sizeof\" operator is invalid on \"function\" symbols\n"
#else
  "\237pe\222\227\341k\207:\257\351bu\200fo\215\204\226\012",
  "\202l\221\255s\303\361\232\213\364\200(\310\356\206) \332 f\265\337w ea\251 \042c\357e\042\012",
  "\214s\210v\363",
  "\254\226 \276\233impl\364t\363",
  "\254\314\221\233\324\362\246t\277",
  "\366\306ign\227\341 \217 \264y\012",
  "\306\210t\223fail\363",
  "\366\255\367\356\206; \306um\227z\210o\012",
  "\253\300\374\201(neg\213i\362\310z\210o\252",
  "\253\254\310\261cl\205\317\012",
  "\253out\325d\201\243\206\277",
  "\253\254c\212l\351\233\255\244add\214\231\012",
  "\220 \207tr\221\340\203\200(\220 pu\234\335 \243\206s\252",
  "\253\232\213\364t; \233\203\372w\262\251\012",
  "\042\302a\336t\321c\357\201\366\355\201l\357\200c\357\201\203\372w\262\251 \232\213\364\331",
  "m\336tip\361\302a\336t\211\203 \042sw\262\251\042\012",
  "\215\343\227\313\305",
  "\203\262i\212iz\213\223d\213\255\237ce\250\211\261cl\205\227\374\270",
  "\233\255la\370l\322",
  "\253\313\326am\201\226\012",
  "\313 \212\214ad\221\343\250\322",
  "\366l\375(n\202-\320\217t\252",
  "\300\306ign\216\200\366\325mp\361\306ign\216\331",
  "\042b\214ak\321\310\042\267t\203ue\321\276ou\200\301\267t\237\331",
  "\254head\352\315ff\210\211from pro\341typ\270",
  "\220 \353\352\042#if...\042\012",
  "\253\251\354\222\260\320\217\331",
  "\347subscript\351\233\217 \264y\012",
  "\253\356\206\351\306um\227z\210o\012",
  "com\340\215\204\232\213\364\200\233c\337s\227a\200\355\201\207\204\301fil\270",
  "\215k\220wn \315\214\222iv\270",
  "\300\203d\237 ou\200\301bo\215d\211\373",
  "\300\366\203d\237\227\373",
  "\266do\330\233\324\362\255\302a\336\200\375(\266%d\252",
  "\266typ\201m\371\353 (\266%d\252",
  "empt\221\232\213\364\331",
  "\253\232r\352(\340\231i\234\221n\202-t\210m\203\213\227\232r\303\252",
  "\237t\247 \251\354\222\210\211\202 l\203\270",
  "\367\313 \324\211\220 \374\270",
  "dupl\335\213\201\042c\357e\321la\370l (\375%d\252",
  "\253ellip\325s\351\300\374\201\276\233k\220wn\012",
  "\253co\235\203\213\223\301cl\357\211specifi\210\277",
  "\251\354\222\260\367\237ce\250\211r\217g\201f\310pack\227\232r\303\012",
  "\340s\262\206\212 p\354met\210\211\323\271c\250\201\212l\326am\227p\354met\210\277",
  "\341o m\217\221\254\246t\277",
  "\215k\220wn \300\374\201\373",
  "\300\374\330\323\353\012",
  "\300\315\216s\206\211\323\353\012",
  "\253l\203\201\267t\203u\317\012",
  "\253r\217g\270",
  "\253subscript\351\256\201\042[ ]\321\376\236\211\202 \314j\310\315\216s\206\277",
  "\202l\221\355\201l\357\200\315\216s\223\314\221\273\312l\207g\355\012",
  "\237ce\250\352\314ximum\326\334\301\315\216s\206\277",
  "\215\353\227c\337s\352b\247c\270",
  "\232\205\200\301\254bod\221w\262hou\200\254head\210\012",
  "\337c\212 \304\263\330\217\204\254\246t\211\347\273pu\234\335 \373",
  "\215f\203\371h\227\356\223\370f\236\201compil\260\315\214\222iv\270",
  "dupl\335\213\201\246t;\372am\201\266\276p\306\227tw\335\270",
  "\254\266\314\221\233\324\362\255\302a\336\200\375\373",
  "m\336tip\361\042#else\321\315\214\222iv\330\370twe\207 \042#i\272... #\207\315f\042\012",
  "\376\310\347\273\214\343\363",
  "n\334\301\345\217d\211do\330\233fi\200\355\201\376\236\012",
  "\376\310\042!\321\214qui\214\211\217 \215tagg\227\254\214s\336\331",
  "\347\251\217g\201\271\343\227\376\236\277",
  "\254\266\314\221\202l\221\324\362\255s\303\361tag (\266%d\252",
  "\254\266\314\221\233\273\255\214f\210\207c\201\266\310\217 \300(\266%d\252",
  "\312\347\273bo\355 \255\214f\210\207c\201\217\204\217 \300\373",
  "\253r\317\212\326\334\271c\371\223\203 #p\247g\314\012",
  "r\317\212\326\334f\236\314\200\212\214ad\221\343\363",
  "r\317\212\326\334supp\236\200wa\211\233\207\263\363"
#endif
       };

static char *fatalmsg[] = {
#ifdef SCPACK
/*100*/  "cannot read from file: \"%s\"\n",
/*101*/  "cannot write to file: \"%s\"\n",
/*102*/  "table overflow: \"%s\"\n",
          /* table can be: loop table
           *               literal table
           *               staging buffer
           *               parser stack (recursive include?)
           *               option table (response file)
           *               peephole optimizer table
           */
/*103*/  "insufficient memory\n",
/*104*/  "invalid assembler instruction \"%s\"\n",
/*105*/  "numeric overflow, exceeding capacity\n"
#else
  "\347\214a\204from file\322",
  "\347wr\262\201\341 file\322",
  "t\274ov\210f\337w\322",
  "\203suff\335i\207\200mem\236y\012",
  "\253\306em\234\260\203\232ru\222\223\226\012",
  "num\210\335 ov\210f\337w\351\237ce\250\352capac\262y\012"
#endif
       };

static char *warnmsg[] = {
#ifdef SCPACK
/*200*/  "symbol \"%s\" is truncated to %d characters\n",
/*201*/  "redefinition of constant (symbol \"%s\")\n",
/*202*/  "number of arguments does not match definition\n",
/*203*/  "symbol is never used: \"%s\"\n",
/*204*/  "symbol is assigned a value that is never used: \"%s\"\n",
/*205*/  "redundant code: constant expression is zero\n",
/*206*/  "redundant test: constant expression is non-zero\n",
/*207*/  "unknown #pragma\n",
/*208*/  "function uses both \"return;\" and \"return <value>;\"\n",
/*209*/  "function should return a value\n",
/*210*/  "possible use of symbol before initialization: \"%s\"\n",
/*211*/  "possibly unintended assignment\n",
/*212*/  "possibly unintended bitwise operation\n",
/*213*/  "tag mismatch\n",
/*214*/  "possibly a \"const\" array argument was intended: \"%s\"\n",
/*215*/  "expression has no effect\n",
/*216*/  "nested comment\n",
/*217*/  "loose indentation\n",
/*218*/  "old style prototypes used with optional semicolumns\n",
/*219*/  "local variable \"%s\" shadows a variable at a preceding level\n",
/*220*/  "exported or native symbol \"%s\" is truncated to %d characters\n",
/*221*/  "label name \"%s\" shadows tag name\n",
/*222*/  "number of digits exceeds rational number precision\n",
/*223*/  "redundant \"sizeof\": argument size is always 1 (symbol \"%s\")\n",
/*224*/  "indeterminate array size in \"sizeof\" expression (symbol \"%s\")\n"
#else
  "\313\257 \276tr\215c\213\227\341 %\204\251\354\222\210\277",
  "\214\343\262\223\301\367(\313\257\252",
  "n\334\301\246t\211do\330\233\353 \343\262\206\012",
  "\313 \276nev\260\256\250\322",
  "\313 \276\306ign\227\255\375t\324\200\276nev\260\256\250\322",
  "\214d\215d\327co\261: \367\356\223\276z\210o\012",
  "\214d\215d\327te\232: \367\356\223\276n\202-z\210o\012",
  "\215k\220wn #p\247g\314\012",
  "\254\256\330bo\355 \042\214turn;\321\217\204\042\214turn <\360e>;\042\012",
  "\254sho\336\204\214turn \255\360\270",
  "\340\231i\234\201\256\201\301\313 \370f\236\201\203\262i\212iz\317\322",
  "\340\231i\234\221\215\203t\207d\227\306ign\216\331",
  "\340\231i\234\221\215\203t\207d\227b\262w\371\201\345\317\012",
  "tag m\371\353\012",
  "\340\231i\234\221\255\042\320\321\300\266wa\211\203t\207d\250\322",
  "\356\223\324\211\220 effe\222\012",
  "ne\232\227com\216\331",
  "\337os\201\203d\207t\317\012",
  "\265\204\232y\361pro\341typ\330\256\227w\262h \342t\206\212\372em\335\265umn\277",
  "\337c\212 \346\372\324dow\211\255\312a\200\255\271c\250\352level\012",
  "\237p\236t\227\310n\213i\362\313\257 \276tr\215c\213\227\341 %\204\251\354\222\210\277",
  "la\370l\326am\201\226\372\324dow\211tag\326am\270",
  "n\334\301\315g\262\211\237ce\250\211r\317\212\326\334\271c\371\206\012"
#endif
       };
